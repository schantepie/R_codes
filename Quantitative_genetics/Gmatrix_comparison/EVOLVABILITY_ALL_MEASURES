
#####################################################
##############" FUNCTION for estimating #############
##############  UNCONDITIONAL EVOLVBILITY ###########
##############  CONDITIONAL EVOLVBILITY #############
##############  AUTONOMY ############################
#############   INTEGRATION  ########################
#####################################################

Evolvability_all <- function(names,nb_pop,names_pop,cpus=1,simu=TRUE,analytic=TRUE){
  
  require(MCMCglmm)
  require(snow)

  #beta generation
  results=list()
  summa_EVOL_MEASURES_beta=array(NA,c(nb_pop,3,5))
  summa_EVOL_MEASURES_analytic=array(NA,c(nb_pop,3,5))
  
for(i in 1:nb_pop){
  gmat=get(paste(names,i,sep=""))
############# estimation with beta
if(simu==TRUE) {

numtr=sqrt(dim(gmat)[2])
trial=1000
beta = matrix(rnorm(trial*numtr), nrow = numtr)
beta = t(beta)/sqrt(colSums(beta^2)) 

Cond_evol_resp_auto_inte<-function(x) {
  G=matrix(x,numtr,numtr)
  Ginv=solve(G)
  G2=G%*%G
  eProj=apply(beta,1,function(x) {t(x)%*%G%*%x})
  eC=apply(beta,1,function(x) {1/(t(x)%*%Ginv%*%x)})
  eR=apply(beta,1,function(x) {sqrt((t(x)%*%G2%*%x))})
  Auto = eC/eProj
  Inte = 1-Auto
  mean_eU=mean(eProj/numtr)
  mean_eC=mean(eC)
  mean_eR=mean(eR)
  mean_Auto=mean(Auto)
  mean_Inte=mean(Inte)
  return(list(mean_eU=mean_eU,
              mean_eC=mean_eC,
              mean_eR=mean_eR,
              mean_Auto=mean_Auto,
              mean_Inte=mean_Inte))
}

  clus <- makeCluster(cpus)
  clusterExport(clus, list("beta","numtr"), envir=environment())
  Evol_measure=parApply(clus,gmat,1,Cond_evol_resp_auto_inte)
  stopCluster(clus)
  EVOL_MEASURE=as.matrix(t(simplify2array(Evol_measure,higher = FALSE)))
  EVOL_MEASURE=mcmc( t(apply(EVOL_MEASURE,1,function(x) simplify2array(x, higher = TRUE))))
  MEASURE=cbind(posterior.mode(EVOL_MEASURE),HPDinterval(EVOL_MEASURE))
  summa_EVOL_MEASURES_beta[i,,]=t(MEASURE)
  dimnames(summa_EVOL_MEASURES_beta)=list(names_pop,c("mode","lower","upper"),c("Unconditional_Evolvability","Contional_Evolvability","Respondability","Autonomy","Integration"))
  results[["summa_EVOL_MEASURES_beta"]]=summa_EVOL_MEASURES_beta
}
  
############# analytic estimation
if( analytic==TRUE){  
    
    Cond_evol_analytic<-function(x) {
      
      G=matrix(x,numtr,numtr)
      eig=eigen(G)
      H=1/(mean(1/eig$values))
      Iinv=var(1/eig$values)/(mean(1/eig$values)^2)
      I2=var(eig$values^2)/((mean(eig$values^2))^2)
      I=var(eig$values)/((mean(eig$values))^2)
      k= dim(G)[1]
      
      mean_eU=mean(eig$values)/k
      mean_eC=H*(1+((2*Iinv)/(k+2)))
      mean_eR = sqrt(mean(eig$values^2))*(1-(I2/(4*(k+2))))
      mean_Auto = (H/mean(eig$values))*(1+2*(I+Iinv-1+(H/mean(eig$values))+2*I*Iinv/(k+2))/(k+2))
      mean_Inte = 1-mean_Auto

      return(list(mean_eU=mean_eU,
                  mean_eC=mean_eC,
                  mean_eR=mean_eR,
                  mean_Auto=mean_Auto,
                  mean_Inte=mean_Inte))
    }
    
    clus <- makeCluster(cpus)
    
    clusterExport(clus, list("numtr"), envir=environment())
    Evol_measure=parApply(clus,gmat,1, Cond_evol_analytic)
    stopCluster(clus)
    EVOL_MEASURE=as.matrix(t(simplify2array(Evol_measure,higher = FALSE)))
    EVOL_MEASURE=mcmc( t(apply(EVOL_MEASURE,1,function(x) simplify2array(x, higher = TRUE))))
    MEASURE=cbind(posterior.mode(EVOL_MEASURE),HPDinterval(EVOL_MEASURE))
    summa_EVOL_MEASURES_analytic[i,,]=t(MEASURE)
    dimnames( summa_EVOL_MEASURES_analytic)=list(names_pop,c("mode","lower","upper"),c("Unconditional_Evolvability","Contional_Evolvability","Respondability","Autonomy","Integration"))
    results[["summa_EVOL_MEASURES_analytic"]]=summa_EVOL_MEASURES_analytic
    }

  }
return (results)
}

###################  EXEMPLE for 8 population
# 
# 
# 
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/blue_bosh_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",1,sep=""),res)
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/blue_calix_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",2,sep=""),res)
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/blue_peerd_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",3,sep=""),res)
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/Blue_korst_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",4,sep=""),res)
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/blue_montrouv_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",5,sep=""),res)
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/blue_corsmuro_CB_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",6,sep=""),res)
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/blue_corsmuro_CV_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",7,sep=""),res)
# load("/media/mnhn/Leca/Gmatrix_project/5_Intra_species_variations/blue_tits/morph/blue_pirio_morph_SI_all_meanstand_OK.Rdata")
# assign(paste("Gmat_",8,sep=""),res)
# 
# 
# 
# names_pop=c("bosh","calix","peerd","korsten","rouviere","muroCB","muroCV","pirio")
# names="Gmat_"
# nb_pop=8
# 
# EVOL=Evolvability_all(names,nb_pop,names_pop,cpus=6)
# 
#
 
  
  
  
  
  
  
  
  
  
  
